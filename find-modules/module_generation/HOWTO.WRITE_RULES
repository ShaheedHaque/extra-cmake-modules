Here are some handy hints for rule writers, in FAQ form...

0. My rule is not firing, how I can debug this?
===============================================

Try the following steps:

- Review the help text output by running "./rule_engine.py --help". Did you
  get the fields in your entry in the right order?

- The first field can be a bit tricky to get right. For the exact name that
  should be used, run "./module_generator.py" with the "--dump-items" option.

- Review the documentation on Python regular expressions. Note that when rule
  matching is done, multi-line entries are converted into a single line with
  any line separators turned into a single space (so a function with arguments
  wrapped across multipel lines is all on one line formatching purposes).

1. I want to keep a given forward declaration
=============================================

By default, built-in rules discard forward declarations because SIP does not
support a forward declaration followed by a real declaration is the same
module.

(See https://www.riverbankcomputing.com/pipermail/pyqt/2017-April/039094.html).

Override the default using a ForwardDeclarationDb rule with the noop() action.

10. I see a SIP compilation error of the following type...
==========================================================

    10.1. sip: ::SomeClass already defined while processing TheModulemod.sip
    ========================================================================

    Unlike C++, SIP does not like multiple declaration of the same item. One
    way this can happen is if a %Import'd module contains a declaration which
    is also in TheModule.

    The unwanted declarations can be fixed by using <item>_discard().

    10.2. sip: tmp/some.sip:42: The struct/class has already been defined while processing TheModulemod.sip
    =======================================================================================================

    Unlike C++, SIP does not like multiple declaration of the same item. One
    way this can happen is if there are multiple declarations in the TheModule
    module.

    The unwanted declarations can be fixed by using <item>_discard(). Note that
    the individual SIP files are %Include'd in alphabetical order. A tricky
    situation arises where, for example, duplicate typedefs occur in the same
    namespace; these extreme cases cannot be handled by the regular expression
    matching for rules, instead, use logic like this:

        def typedef_duplicate_discard(container, typedef, sip, rule):
            if container.translation_unit.spelling.endswith("storejob.h"):
                rule_helpers.typedef_discard(container, typedef, sip, rule)
            else:
                return rule_helpers.SILENT_NOOP

    See also FAQ #10.20.

    10.20. sip: SomeClass is undefined while processing TheModulemod.sip
    ====================================================================

    One reason this can happen is because of FAQ #1. However, fixing that can
    reveal errors like FAQ #10.2, and fixing that can cause this error.

    The missing declaration can be inserted using module_add_classes().

    10.30. sip: someMethodOrCtor argument n has an unsupported type for a Python signature...
    =========================================================================================

    SIP is very restrictive in what it will accept as a function argument type, with templates
    being a particular problem even when a %MappedType is in place.

    A synthetic typedef is often needed, and can be inserted using module_add_typedefs().


20. I see a C++ compilation error of the following type...
==========================================================

    20.1. error: expected type-specifier before 'sipMyClass'
    ========================================================

    For C++ class 'MyClass', SIP sometimes creates a subclass called
    'sipMyClass', but not always. This cannot easily be detected, and can
    result in this error in generated code.

    (See https://www.riverbankcomputing.com/pipermail/pyqt/2017-June/039309.html)

    This can be fixed using container_fake_derived_class().

    20.2. error: use of deleted function 'SomeClass& SomeClass::operator=(const SomeClass&)'
    ========================================================================================

    For C++ class 'SomeClass', SIP creates a function called 'assign_SomeClass'
    but this relies on the operator= being present. C++ causes the default
    operator= to be suppressed resulting in this error if a base class cannot
    be so assigned. However, the built-in logic has not been able to emit
    the needed private assignment operator.

    This can be fixed using container_make_unassignable().

    20.3. error: use of deleted function 'SomeClass(const SomeClass&)'
    ==================================================================

    For C++ class 'SomeClass', the built-in logic has not been able to emit
    the needed private copy constructor.

    This can be fixed using container_make_uncopyable().

    20.10. error: 'sipType_MyClass' was not declared in this scope
    ============================================================

    The module_generator.py logic which generates the list of modules which
    must be %Import'd cannot always detect the complete list, and in this case,
    a %Import is required for the module which contains MyClass.

    This can be fixed using module_add_imports().
