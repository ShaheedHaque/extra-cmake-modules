Here are some handy hints for rule writers, in FAQ form...

0. My rule is not firing, how I can debug this?
===============================================

Try the following steps:

- Review the help text output by running "./rule_engine.py --help". Did you
  get the fields in your entry in the right order?

- The first field can be a bit tricky to get right. For the exact name that
  should be used, run "./module_generator.py" with the "--dump-items" option.

- Review the documentation on Python regular expressions. Note that when rule
  matching is done, multi-line entries are converted into a single line with
  any line separators turned into a single space (so a function with arguments
  wrapped across multipel lines is all on one line formatching purposes).

1. I want to keep a given forward declaration
=============================================

By default, built-in rules discard forward declarations because SIP does not
support a forward declaration followed by a real declaration is the same
module.

(See https://www.riverbankcomputing.com/pipermail/pyqt/2017-April/039094.html).

Override the default using a ForwardDeclarationDb rule with the noop() action.

10. I see a SIP error of the following type...
======================================================

    10.1. sip: ::SomeClass already defined while processing TheModulemod.sip
    ========================================================================

    Unlike C++, SIP does not like multiple declaration of the same item. One
    way this can happen is if a %Import'd module contains a declaration which
    is also in TheModule.

    The unwanted declarations can be fixed by using <item>_discard().

    10.2. sip: tmp/some.sip:42: The struct/class has already been defined while processing TheModulemod.sip
    =======================================================================================================

    Unlike C++, SIP does not like multiple declaration of the same item. One
    way this can happen is if there are multiple declarations in the TheModule
    module.

    The unwanted declarations can be fixed by using <item>_discard(). Note that
    the individual SIP files are %Include'd in alphabetical order. A tricky
    situation arises where, for example, duplicate typedefs occur in the same
    namespace; these extreme cases cannot be handled by the regular expression
    matching for rules, instead, use logic like this:

        def typedef_duplicate_discard(container, typedef, sip, rule):
            if container.translation_unit.spelling.endswith("storejob.h"):
                rule_helpers.typedef_discard(container, typedef, sip, rule)
            else:
                return rule_helpers.SILENT_NOOP

    See also FAQ #10.20.

    10.20. sip: SomeClass is undefined while processing TheModulemod.sip
    ====================================================================

    One reason this can happen is because of FAQ #1. However, fixing that can
    reveal errors like FAQ #10.2, and fixing that can cause this error.

    The missing declaration can be inserted using module_add_classes().

20. I see a compilation error of the following type...
======================================================

    20.1. error: expected type-specifier before 'sipMyClass'
    ========================================================

    For C++ class 'MyClass', SIP sometimes creates a subclass called
    'sipMyClass', but not always. This cannot easily be detected, and can
    result in this error in generated code.

    (See https://www.riverbankcomputing.com/pipermail/pyqt/2017-June/039309.html)

    This can be fixed using container_fake_derived_class().

    20.2. error: use of deleted function 'SomeClass& SomeClass::operator=(const SomeClass&)'
    ========================================================================================

    For C++ class 'SomeClass', SIP creates a function called 'assign_SomeClass'
    but this relies on the operator= being present. C++ causes the default
    operator= to be suppressed resulting in this error if a base class cannot
    be so assigned. However, the built-in logic has not been able to emit
    the needed private assignment operator.

    This can be fixed using container_make_unassignable().

    20.3. error: use of deleted function 'SomeClass(const SomeClass&)'
    ==================================================================

    For C++ class 'SomeClass', the built-in logic has not been able to emit
    the needed private copy constructor.

    This can be fixed using container_make_uncopyable().

    20.10. error: 'sipType_MyClass' was not declared in this scope
    ============================================================

    The module_generator.py logic which generates the list of modules which
    must be %Import'd cannot always detect the complete list, and in this case,
    a %Import is required for the module which contains MyClass.

    This can be fixed using module_add_imports().
"""
import os
import re

from utils import decompose_type_names, fqn, trace_inserted_for, trace_discarded_by, trace_generated_for

ANNOTATIONS_RE = re.compile(" /.*/")

#
# By default, rules return None. This causes the rule-firing logic to emit
# diagnostics recording what, if anything, changed. Rules which want to
# suppress "nothing changed" messages should return SILENT_NOOP.
#
SILENT_NOOP = "do-not-report-lack-of-changes"


def initialise_cxx_decl(sip):
    """
    Initialise a C++ declaration.

    :param sip:
    :return: Any annotations we found.
    """
    annotations = []
    sip["cxx_parameters"] = []
    for p in sip["parameters"]:
        a = ANNOTATIONS_RE.search(p)
        if a:
            a = a.group()
            p = ANNOTATIONS_RE.sub("", p)
        else:
            a = ""
        annotations.append(a)
        sip["cxx_parameters"].append(p)
    sip["cxx_fn_result"] = sip["fn_result"]
    return annotations


def noop(*args):
    """
    This action function "does nothing" but without causing a warning.
    For example, using this as the action in an ForwardDeclarationDb entry can
    be used to override the default "drop forward declarations" rule.
    """
    return SILENT_NOOP


def container_discard(container, sip, matcher):
    sip["name"] = ""


def forward_declaration_discard(container, sip, matcher):
    sip["name"] = ""


def function_discard(container, function, sip, matcher):
    sip["name"] = ""


def typedef_discard(container, typedef, sip, matcher):
    sip["name"] = ""


def variable_discard(container, variable, sip, matcher):
    sip["name"] = ""


def unexposed_discard(container, unexposed, sip, matcher):
    sip["name"] = ""


def container_discard_QSharedData_base(container, sip, matcher):
    sip["base_specifiers"].remove("QSharedData")


def container_mark_abstract(container, sip, matcher):
    sip["annotations"].add("Abstract")


def forward_declaration_mark_external(container, sip, matcher):
    sip["annotations"].add("External")


def parameter_in(container, function, parameter, sip, matcher):
    sip["annotations"].add("In")


def parameter_out(container, function, parameter, sip, matcher):
    sip["annotations"].add("Out")


def parameter_transfer_to_parent(container, function, parameter, sip, matcher):
    if function.is_static_method():
        sip["annotations"].add("Transfer")
    else:
        sip["annotations"].add("TransferThis")


def param_rewrite_mode_t_as_int(container, function, parameter, sip, matcher):
    sip["decl"] = sip["decl"].replace("mode_t", "unsigned int")


def parameter_strip_class_enum(container, function, parameter, sip, matcher):
    sip["decl"] = sip["decl"].replace("class ", "").replace("enum ", "")


def modulecode_delete(filename, sip, rule, *keys):
    """
    Delete duplicate modulecode entries from the current module.
    This prevents clashes when the current module A, imports B and both define
    the same thing.

    :param filename:        The filename of the module, e.g. KCoreAddonsmod.sip.
    :param sip:             The sip.
    :param rule:            The rule.
    :param keys:            The keys to the entries.
    """
    for key in keys:
        trace = trace_discarded_by(key, rule)
        del sip["modulecode"][key]
        sip["modulecode"][key] = trace


def modulecode_make_local(filename, sip, rule, *keys):
    """
    Make modulecode entries local to the current module using the feature name.
    This prevents clashes when the current module A, and another module B both:

        - define the same thing
        - are imported by a third module C

    :param filename:        The filename of the module, e.g. KCoreAddonsmod.sip.
    :param sip:             The sip.
    :param rule:            The rule.
    :param keys:            The keys to the entries.
    """
    feature = os.path.splitext(filename)[0].replace(os.path.sep, "_")
    for key in keys:
        tmp = sip["modulecode"][key]
        trace = trace_inserted_for(key, rule)
        tmp = trace + "%If (!" + feature + ")\n" + tmp + "%End\n"
        sip["modulecode"][key] = tmp


def module_add_classes(filename, sip, rule, *classes):
    """
    Add missing class declarations to a module.

    :param filename:        The filename of the module, e.g. KCoreAddonsmod.sip.
    :param sip:             The sip.
    :param rule:            The rule.
    :param classes:         The classes to add.
    """
    feature = os.path.splitext(filename)[0].replace(os.path.sep, "_")
    tmp = ""
    for key in classes:
        tmp += "class " + key + ";\n"
    trace = trace_generated_for(sip["name"], rule, "missing classes")
    tmp = trace + "%If (!" + feature + ")\n" + tmp + "%End\n"
    sip["code"] += tmp


def module_add_imports(filename, sip, rule, *modules):
    """
    Add missing imports to a module.

    :param filename:        The filename of the module, e.g. KCoreAddonsmod.sip.
    :param sip:             The sip.
    :param rule:            The rule.
    :param modules:         The modules to add.
    """
    feature = os.path.splitext(filename)[0].replace(os.path.sep, "_")
    tmp = ""
    for key in modules:
        tmp += "%Import(name=" + key + ")\n"
    trace = trace_generated_for(sip["name"], rule, "missing imports")
    tmp = trace + "%If (!" + feature + ")\n" + tmp + "%End\n"
    sip["code"] += tmp


def module_delete_imports(filename, sip, rule, *modules):
    """
    Remove unwanted imports from a module.

    :param filename:        The filename of the module, e.g. KCoreAddonsmod.sip.
    :param sip:             The sip.
    :param rule:            The rule.
    :param modules:         The modules to remove.
    """
    trace = trace_generated_for(sip["name"], rule, "delete imports")
    lines = []
    for l in sip["decl"].split("\n"):
        l = l.strip()
        if l.startswith("%Import"):
            m = l[:-1].split("=", 1)[1]
            if m in modules:
                lines.append(trace)
                lines.append("// " + l)
                continue
        lines.append(l)
    sip["decl"] = "\n".join(lines)


def module_yank_scoped_class(filename, sip, rule):
    """
    SIP does not support classes defined with a scoped name, such as A::B.
    We physically yank things into place.
    """
    child = "^    class " + sip["ctx"]["child"] + "\\b[^\n]*\n    {.*?(^    };)$"
    parent = "^    class " + sip["ctx"]["parent"] + "\\b[^\n]*\n    {.*?(^    };)$"
    trace_from = trace_generated_for(sip["name"], rule, "yanking '{}' into '{}'".format(sip["ctx"]["child"], sip["ctx"]["parent"]))
    trace_to = trace_generated_for(sip["name"], rule, "yanked '{}' into '{}'".format(sip["ctx"]["child"], sip["ctx"]["parent"]))
    #
    #
    #
    child = re.search(child, sip["decl"], re.DOTALL | re.MULTILINE)
    tmp = sip["decl"][:child.start(0)] + trace_from[:-1] + sip["decl"][child.end(0):]
    parent = re.search(parent, tmp, re.DOTALL | re.MULTILINE)
    sip["decl"] = tmp[:parent.start(1)] + trace_to + "    public:\n" + child.group(0) + "\n" + tmp[parent.start(1):]


def module_add_includes(filename, sip, rule, *includes):
    """
    There are many cases where adding a #include is a useful workaround.

    :param filename:        The filename of the module, e.g. KCoreAddonsmod.sip.
    :param sip:             The sip.
    :param rule:            The rule.
    :param includes:        The includes to add.
    """
    tmp = ""
    for key in includes:
        tmp += "#include " + key + "\n"
    trace = trace_generated_for(sip["name"], rule, "missing includes")
    tmp = trace + "%ModuleHeaderCode\n" + tmp + "%End\n"
    sip["code"] += tmp


def container_add_typedefs(container, sip, rule, *typedefs):
    """
    There are many cases of types which SIP cannot handle, but where adding a C++ typedef is a useful workaround.

    :param container:       The container in question.
    :param sip:             The sip.
    :param rule:            The rule.
    :param typedefs:        The typedefs to add.
    """
    def get_template(typedef, parent):
        """
        Any template parameters from the parent in "typedef" must be extracted,
        and presented as template parameters for the typedef, so for

            template<A, B, C, D>
            class Foo
            {
            public:
                typedef DoesNotUseBorC<A, D> Bar;
            }

        we need to extract <B, C> to enable:

            template<B, C>
            typedef Foo::Bar;

        TODO: this actually needs to take the templating_stack into account.
        """
        if parent.template_parameters is None:
            return None
        name, args = decompose_type_names(typedef)
        ids = []
        if args:
            for arg in args:
                ids.extend([a.strip() for a in re.split(",| |::|<|>|\*|&", arg) if a])
        ids.extend(name.split("::"))
        ids = [a for a in ids if a in parent.template_parameters]
        return ", ".join(ids)

    typeheadercode = ""
    trace = trace_generated_for(sip["name"], rule, "supplementary typedefs")
    for new_typedef, original_type in enumerate(typedefs):
        new_typedef = "__{}{}_t".format(container.spelling, new_typedef)
        typedef_template = get_template(original_type, container)
        #
        # Generate a C++ typedef in %TypeHeaderCode.
        #
        if typedef_template:
            typeheadercode += "    template<" + typedef_template + ">\n"
        typeheadercode += "    typedef " + original_type + " " + new_typedef + ";\n"
        sip["body"] = sip["body"].replace(original_type, new_typedef)
        sip["modulecode"][new_typedef] = "class " + new_typedef + ";\n"
    sip["code"] += trace + "%TypeHeaderCode\n" + typeheadercode + "%End\n"


def container_fake_derived_class(container, sip, rule):
    """
    There are many cases where SIP does not generate a derived class, and
    having a #define to fake one makes writing manual code easier. See

    https://www.riverbankcomputing.com/pipermail/pyqt/2017-June/039309.html

    :param container:       The container in question.
    :param sip:             The sip.
    :param rule:            The rule.
    :param includes:        The includes to add.
    """
    clazz = fqn(container)
    tmp = "#define sip{} {}\n".format(clazz.replace("::", "_"), clazz)
    trace = trace_generated_for(sip["name"], rule, "fake derived class")
    tmp = trace + "%TypeHeaderCode\n" + tmp + "%End\n"
    sip["code"] += tmp


def container_discard_templated_bases(container, sip, rule):
    """
    SIP cannot handle base templates like "class Foo: Bar<Baz>" without an
    intermediate typedef. For now, delete the base class. See

    https://www.riverbankcomputing.com/pipermail/pyqt/2017-August/039476.html

    :param container:       The container in question.
    :param sip:             The sip.
    :param rule:            The rule.
    :param includes:        The includes to add.
    """
    sip["base_specifiers"] = [b for b in sip["base_specifiers"] if "<" not in b]


def container_make_unassignable(container, sip, rule):
    """
    There are many cases of types which SIP cannot handle, but where adding a C++ typedef is a useful workaround.

    :param container:       The container in question.
    :param sip:             The sip.
    :param rule:            The rule.
    """
    clazz = fqn(container)
    tmp = "    private:\n        {} &operator=(const {} &);\n".format(clazz, clazz)
    trace = trace_generated_for(sip["name"], rule, "dummy assignment")
    tmp = trace + tmp
    sip["body"] = tmp + sip["body"]
